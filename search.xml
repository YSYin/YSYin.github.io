<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    
    
    <entry>
      <title>Git III: Github</title>
      <link href="%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/Git-III-Github/"/>
      <url>%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/Git-III-Github/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Github是通过Git进行版本控制的软件源代码托管服务平台，很多开源项目使用Github进行Git托管、问题追踪、代码审查等诸多操作，Github也是当前最大的开源社区，通过Github我们可以学习优秀的开源项目、进行多人协作项目等等。基于<strong>Pro Git 2</strong>和<strong>stormzhang的从0开始学习Github</strong>，本文将介绍如何高效的使用Github。</p><h2 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h2><p>首先，我们需要注册一个Github账号，并进行相关配置，过程不再赘述，按照提示操作即可。</p><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><ul><li>Repository：仓库，即在Github上开源的项目</li><li>Issue：问题，即其他用户对某个项目提出的问题、bug或者改进建议</li><li>Star：点赞，其他用户对项目表示赞赏和支持</li><li>Fork：派生，其他用户如想对你的项目进行贡献，则需要先对项目进行派生，也就是把该项目复制一份副本，然后就可以做出自己的改进</li><li>Pull Request：归并请求，在其他用户Fork并做出改进后，用户就可以向项目的作者提出归并请求，即请求原作者把自己的改进合并到原项目中（<strong>注</strong>：Pull Request的中文释义是一个很有趣的问题，单纯从Pull+Request的角度似乎无法透彻的表达其“合并请求”的含义，知乎上有一个问题对此进行了讨论（<a href="https://www.zhihu.com/question/21682976">https://www.zhihu.com/question/21682976</a> ），一种可解释性较强的理解是：Request the Project Owner to Pull my Modification，即向项目作者发送请求，该请求是让其合并自己所作的修改）</li><li>Watch：观察，对项目进行Watch后，该项目进行任何更新你都会收到项目的通知提醒</li></ul><h2 id="创建项目"><a class="markdownIt-Anchor" href="#创建项目"></a> 创建项目</h2><p>通过导航栏的<code>＋</code>下的<code>New repository</code>选项，可以创建一个项目仓库。创建项目需要填写项目名称、项目描述（可选），然后选择项目是Public（所有人都可见）和Private（指定部分人可见）属性，并勾选是否添加<code>README</code>文件、是否添加<code>.gitignore</code>文件、是否添加项目协议，然后就可创建一个你自己的项目仓库Repository。</p><h2 id="提交代码"><a class="markdownIt-Anchor" href="#提交代码"></a> 提交代码</h2><h3 id="ssh"><a class="markdownIt-Anchor" href="#ssh"></a> SSH</h3><p>任何人都可以自由的下载Github上的所有Public项目仓库；拥有Github账号后，用户可以选择创建自己的项目；通过授权机制，用户可以向自己有权限的仓库上传代码。在Github中，这种授权机制一般通过SSH实现。</p><p>SSH（Secure Shell）是一种网络协议，用于计算机之间的远程加密登录。SSH一般的登陆过程是：</p><ul><li>用户发起登录请求</li><li>远程主机收到用户的登陆请求，把自己的公钥发给用户</li><li>用户收到公钥后，将登录密码加密，返回给远程主机</li><li>远程主机用自己的私钥，解密登录密码，并与数据库进行比对，若密码正确，则同意登录</li></ul><p>为了防备中间人攻击（即攻击者伪装成远程主机向用户发送自己的公钥），在第一次登录远程主机时，SSH会向用户输出提示，告知用户主机公钥的MD5指纹，让用户自行判断该公钥是否可以信任，如果可以信任，则按上述步骤进行登录。</p><p>通过上述机制，用户每次都需要输入用户名和密码，较为繁琐，因此，SSH提供一种免密登陆方法：</p><ul><li>用户在自己的客户机上生成一份公钥和私钥（或以前已经具有的）</li><li>用户将自己的公钥存储到远程主机上</li><li>用户发起登陆请求</li><li>远程主机收到登陆请求，向用户发送一段随机字符串</li><li>用户收到字符串，用自己的私钥加密后返回给远程主机</li><li>远程主机用自己之前存储的用户公钥解密字符串，如果解密后和原字符串相同，则说明用户可信，同意登录</li></ul><p>在Linux或者MinGW上，通过<code>ssh-keygen -t rsa</code>命令，用户可以生成一份自己的公钥和私钥（一般来说主机上的一个用户只能有一份公私钥），并存储在<code>$HOME/.ssh$</code>目录内，分别命名为<code>id_rsa.pub(公钥)</code>和<code>id_rsa(私钥)</code>，在生成公私钥时，可以选择是否对私钥设置口令<code>passphrase</code>，即只有输入该口令的用户才能获得私钥的使用权（输入口令后较长一段时间内都可获得私钥的使用权）</p><p>为了在提交代码时进行免密登陆，我们可以将自己主机的公钥添加到Github中，通过设置=&gt;SSH and GPG keys=&gt;New SSH key即可添加公钥</p><h3 id="pushpull"><a class="markdownIt-Anchor" href="#pushpull"></a> PUSH&amp;PULL</h3><p>根据Git I-II中所述的内容，我们通过<code>git push</code>和<code>git pull</code>指令与远程仓库分支进行数据交换，push和pull会自动通过SSH进行免密登陆。</p><p><strong>注意</strong>：Github中传输文件的协议一般有两种：HTTPS和SSH，以上的SSH免密登陆仅适用于通过SSH方式传输文件，即remote的url为<code>git@github.com:</code>格式</p><p>Github中SSH协议和HTTPS协议的区别可以参考这篇博客：<a href="https://blog.cuiyongjian.com/engineering/git-https-ssh/">https://blog.cuiyongjian.com/engineering/git-https-ssh/</a></p><h2 id="forkpull-requests"><a class="markdownIt-Anchor" href="#forkpull-requests"></a> Fork+Pull Requests</h2><p>如果你想要参与某个项目，但是没有推送权限，此时可以选择<strong>Fork</strong>项目，<strong>Fork</strong>操作会在你的空间中创建一个项目副本，并且你对项目具有推送权限，此时，你可以将修改推送到项目副本中，并通过创建合并请求(<strong>Pull Request</strong>)来使改动进入源版本库，创建合并请求后，就会开启一个可供审查代码的版块，项目的拥有者和贡献者可以在此讨论相关修改，直到项目拥有者对其感到满意，并且将这些修改合并到版本库。</p><p>Github设计了一个以合并请求为中心的特殊合作流程：</p><ul><li>从项目副本的<code>master</code>分支中创建一个新分支</li><li>提交一些修改改进项目</li><li>将该分支推送到Github上</li><li>创建一个合并请求Pull Request</li><li>讨论，根据实际情况继续修改</li><li>项目的拥有者合并或关闭你的合并请求</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git II: 分支</title>
      <link href="%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/Git-II-%E5%88%86%E6%94%AF/"/>
      <url>%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/Git-II-%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>几乎所有版本控制系统都以某种形式支持分支：这意味着可以将工作从开发主线上分离开来，以免影响开发主线。与其他版本控制系统相比，Git的分支模型极为突出：可以快速、高效的创建分支和切换分支；而且Git鼓励频繁的使用分支和合并。基于<strong>Pro Git 2</strong>，本文将介绍Git的分支模型。</p><h2 id="前言git数据保存方式"><a class="markdownIt-Anchor" href="#前言git数据保存方式"></a> 前言：Git数据保存方式</h2><p>如前所述，<strong>Git保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照</strong>。</p><p>在执行暂存操作时(<code>git add</code>)，Git会为工作目录中的每一个文件计算SHA-1校验和，然后将当前版本的<strong>文件快照保存到Git仓库</strong>中（使用blob对象），将<strong>校验和添加到暂存区域文件</strong>中等待提交。</p><p>在执行提交操作时(<code>git commit</code>)，Git会<em>先计算每一个子目录的校验和</em>（从暂存区域中获得），然后在Git仓库中将这些校验和保存为<strong>树对象</strong>，随后，Git会创建一个提交对象，它包含作者的姓名和邮箱、提交时输入的信息、指向树对象的指针；做些修改后再次提交，那么这次的提交对象还会包括一个指向上次提交对象（父对象）的指针</p><p>事实上，Git提交时只会提交所有存在于暂存区域上的文件，而且提交后暂存区域也不会清空。</p><p>Git的分支本质上仅仅是指向提交对象的<strong>可变指针</strong>，Git的默认分支名字是<code>master</code>（<strong>自2020年10月1日起，Github的默认分支名为main，Git2.28以上版本也支持自定义默认分支名</strong>）；在每次提交时，master指针会自动向前移动，确保指向最新的提交对象</p><h2 id="分支操作"><a class="markdownIt-Anchor" href="#分支操作"></a> 分支操作</h2><h3 id="创建分支"><a class="markdownIt-Anchor" href="#创建分支"></a> 创建分支</h3><p>通过<code>git branch &lt;name&gt;</code>命令，Git会创建一个指向当前最新提交对象的可移动指针，该指针即为该分支；该命令仅创建分支，不会自动切换分支。</p><p>如前所述，Git的master分支也默认指向当前最新提交，那么需要一种方式区分当前正处在哪个分支之中（只有这样之后所作的改动才能关联到分支上）；在Git中，一个名为<code>HEAD</code>的特殊指针用于指向<strong>当前所在的本地分支</strong>，可以把HEAD当做当前所在分支的一个别名</p><p>可以通过<code>git log --decorate</code>命令查看各个分支、HEAD、标签指向的提交对象</p><h3 id="切换分支"><a class="markdownIt-Anchor" href="#切换分支"></a> 切换分支</h3><p>通过<code>git checkout &lt;name&gt;</code>命令，可以切换到name分支，此时HEAD指向name分支</p><p><strong>分支切换会改变工作目录中的文件</strong>：如果切换到一个旧的分支，工作目录会恢复到该分支最后一次提交时的文件状态和内容；切换分支前，最好确保当前分支的工作目录、暂存区域和最后一次提交保持一致，即切换前把全部修改提交或放弃。</p><p>通过切换到不同的分支进行工作，Git的提交对象链会出现分叉，可以通过<code>git log --oneline --decorate --graph --all</code>查看提交历史、分支指向和项目的分支分叉情况</p><p>通过<code>git checkout -b &lt;name&gt;</code>可以同时创建并切换到name分支</p><h3 id="删除分支"><a class="markdownIt-Anchor" href="#删除分支"></a> 删除分支</h3><p>通过<code>git branch -d &lt;name&gt;</code>命令可以删除分支</p><h3 id="合并分支"><a class="markdownIt-Anchor" href="#合并分支"></a> 合并分支</h3><p>在当前分支中执行<code>git merge name</code>命令，可以合并当前分支和name分支，并把当前分支指向合并的结果，实际的合并方式有如下几种：</p><ul><li><p>快进合并（Fast-forward）：合并的两个分支存在直接的上下游关系，即沿着某一分支前进能得到另一分支，则合并的结果是最新的分支，这种方式下没有分歧，也没有新的提交</p></li><li><p>三方合并：合并的两个分支位于不同的分支叉上，则Git会使用两个分支的末端所指的快照和这两个分支的最优共同祖先，做三方合并，Git会把合并结果做一个新的提交，并把当前分支指针指向该提交，注意：</p><ul><li><p>该提交有两个父对象，分别是两个分支</p></li><li><p><em>三方合并的共同祖先由Git自行选取，不一定是最近共同祖先</em>（不确定）</p></li><li><p>三方合并的执行原理是：比较两个分支的文件的每一行，相同则保留，如果这一行不同，就把它和共同祖先的那一行进行比较，保留与共同祖先的这一行不同的行（说明这是新的修改，应该合并进去）</p></li><li><p>在三方合并时，可以会出现冲突（即两个分支都对某个文件的某个部分进行了修改，三方合并无法确认哪一个修改是最新的），此时Git会暂停下来，输出合并冲突。通过<code>git status</code>命令可以查看那些因处于合并冲突而处于未合并状态的文件，然后，Git会在工作目录中的相关冲突文件中加入标准的冲突解决标记，我们打开文件、修改文件、删除冲突标记，通过<code>add</code>命令暂存表明冲突已解决，最后执行<code>commit</code>提交</p></li><li><p>Git的冲突标志是<code>&lt;&lt;&lt;&lt;&lt;======&gt;&gt;&gt;&gt;&gt;</code></p><p><img src="https://cdn.jsdelivr.net/gh/YSYin/YLogCDN/img/20210207123533.png" alt="示例" /></p></li><li><p>也可以通过<code>git mergetool</code>通过图形化工具解决冲突</p></li></ul></li></ul><h3 id="管理分支"><a class="markdownIt-Anchor" href="#管理分支"></a> 管理分支</h3><ul><li>通过<code>git branch</code>命令可以列出当前所有分支<ul><li>添加<code>-v</code>选项可以查看每一个分支的最后一次提交</li><li>添加<code>--merged</code>选项可以查看哪些分支已经合并到当前分支<ul><li>对于已经合并的分支，可以通过-d选项删除分支</li></ul></li><li>添加<code>--no-merged</code>选项可以查看哪些分支没有合并到当前分支<ul><li>对于未合并的分支，通过-d选项删除会报错，通过-D选项可以强制删除</li></ul></li></ul></li></ul><h3 id="分支工作流"><a class="markdownIt-Anchor" href="#分支工作流"></a> 分支工作流</h3><p>长期分支：只在master分支上保留完全稳定的代码，而在一些<code>develop</code>分支上进行后续开发或测试稳定性</p><p>特性分支：实现单一特性或相关工作，稳定后可以被合并到长期分支中，然后删除</p><h3 id="远程分支"><a class="markdownIt-Anchor" href="#远程分支"></a> 远程分支</h3><p>远程跟踪分支是远程分支状态的引用，不能被个人移动，但在进行任何网络通信操作时，会自动移动。<strong>远程跟踪分支是上次连接远程仓库时，分支所处状态的书签</strong>。</p><p>远程分支以<code>remote-name/branch-name</code>形式命名</p><p>在我们通过克隆方式下载一个Git仓库时，本地的<code>master</code>分支和<code>origin /master</code>分支同时指向当前的最新的提交，然后，我们可以在本地进行修改和更新，本地的<code>master</code>分支会不断前进，而<code>origin /master</code>分支不会移动，在运行<code>git fetch origin</code>命令后，Git会连接远程仓库服务器，从中抓取本地没有的数据，并更新本地数据库，此时，<code>origin /master</code>分支会指向抓取到的最新的提交；注意，此时<code>origin /master</code>分支和<code>master</code>分支会形成分支叉</p><p>通过<code>git push remote-name branch-name</code>命令，我们可以将本地的branch-name分支推送到remote服务器的branch-name分支，通过<code>git push remote-name lbn:rbn</code>，我们可以将本地的lbn分支推送到remote的rbn分支</p><p>在通过fetch抓取远程服务器时，如果远程服务器出现新的分支（可能是其他贡献者提交），则本地会出现一个origin/new-b分支，该分支是不可移动的，如果本地想要合并该分支，则可以通过<code>git merge origin/new-b</code>命令合并；如果本地想要在这个新的分支上工作，则可以通过<code>git checkout -b new-b origin/new-b</code>命令来新建一个本地分支，该分支指向远程分支的最新提交</p><p>当克隆一个仓库时，Git会自动创建一个<strong>跟踪</strong><code>origin/master</code>的<code>master</code>分支</p><ul><li>跟踪分支是与远程分支有直接关系的本地分支，如果在跟踪分支上输入<code>git pull</code>，Git会自动的向目标服务器的目标分支抓取并合并</li><li>可以手动创建一个跟踪某个分支的跟踪分支，之前使用的<code>git checkout -b new-b origin/new-b</code>命令即可创建相应的跟踪分支</li><li>也可以使用<code>git checkout --track origin/new-b</code>来自动创建一个本地的跟踪分支</li><li>通过<code>git branch -u origin/new-b</code>或者<code>git branch --set-upstream-to origin/new-b</code>可以将当前所在分支设定为new-b的跟踪分支</li><li>在设置好跟踪分支后，可以通过<code>@&#123;upstream&#125;</code>或者<code>@&#123;u&#125;</code>快捷方式来指代远程分支</li><li>通过<code>git branch -vv</code>命令可以列出所有的本地分支和其跟踪信息：是否领先、落后或是都有</li></ul><p>通过<code>git fetch</code>命令从服务器获取数据时，不会修改工作目录的内容，只会更改远程分支、让你自己合并；通过<code>git pull</code>命令，Git会自动抓取当前分支所跟踪的分支的最新内容，然后合并到当前分支中，pull=fetch+merge</p><p>通过<code>git push origin --delete b</code>命令，可以删除远程服务器上的b分支</p><h3 id="变基"><a class="markdownIt-Anchor" href="#变基"></a> 变基</h3><p>Git中整合不同分支的方法主要有两种：<code>merge</code>和<code>rebase</code></p><ul><li><code>merge</code>操作会采用三方合并的方式进行整合，会产生一个新的提交，该提交有两个父对象</li><li><code>rebase</code>操作会提取在一个分支中引入的补丁和修改，然后在当前分支的基础上再应用一次（变基），从而产生一个新的提交，该提交仅有一个父对象，且和当前分支一脉相承</li></ul><p><code>rebase</code>操作的具体原理是：</p><ul><li>首先找到两个分支的最近共同祖先，然后对比<strong>当前分支</strong>相对于共同祖先的历次提交，提取相应的修改并存为临时文件</li><li>然后切换分支到目标分支</li><li>将保存的临时文件中的修改依次应用到目标分支中，产生一个新的提交</li><li>将原分支指向该新提交，并切换到该分支</li></ul><p>执行完rebase后，仍处在原分支之中，但此时分支已经处于目标分支的上游，故采用快进方式合并即可：</p><ul><li>切换到目标分支</li><li>执行<code>git merge ob</code>命令快进</li></ul><p>再总结一下merge（指三方合并）和rebase的区别和联系：</p><ul><li>merge和rebase的最终结果都是相同的，如果有冲突，也都需要解决冲突</li><li>merge的执行者是目标分支（主分支），rebase的执行者是源分支（子分支，即要被合并的分支）</li><li>rebase执行完后，还需要切换到目标分支执行一次merge（快进合并）</li><li>merge的归并结果是一个新的提交，该提交具有两个父对象</li><li>rebase的归并结果是一个新的提交，该提交具有一个父对象</li><li>变基的目的是确保在向远程分支推送时保持提交历史的整洁，而且方便维护者的整合工作（整合工作都是子分支完成的，而不是由维护者完成的）</li><li>merge和rebase的权衡之处在于：如何看待提交历史；merge忠实的保存每一次提交历史，而rebase则专注于掩盖混乱的历史，使合并变得有序整洁</li></ul><p>rebase的其他用法：</p><ul><li><code>git rebase --onto master server client</code>：取出client分支，找出处于client分支和server分支的共同祖先之后的修改，然后把它们在master分支中重演一遍，即将部分client分支变基到master分子</li><li><code>git rebase master server</code>：将server分支变基到master分支</li></ul><p><strong>变基的准则：不要对个人仓库之外存有副本的分支执行变基；即：只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git I: 基础</title>
      <link href="%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/Git-I-%E5%9F%BA%E7%A1%80/"/>
      <url>%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7%E6%8A%80%E8%83%BD/Git-I-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理，最初由Linus Torvalds着手开发，现在已成为一个广泛使用的版本控制工具。基于<strong>Scott Chacon、Ben Straub</strong>所著的<strong>Pro Git 2</strong>，本文将介绍Git的历史、特性与基础使用。</p><h2 id="前言版本控制"><a class="markdownIt-Anchor" href="#前言版本控制"></a> 前言：版本控制</h2><p>版本控制系统(<strong>VCS</strong>)是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。通过VCS，我们能轻松的回溯项目状态、比较文件变化细节、记录文件修改历史。在VCS的发展过程中，出现了几种典型的系统架构。</p><h3 id="本地版本控制系统"><a class="markdownIt-Anchor" href="#本地版本控制系统"></a> 本地版本控制系统</h3><p><img src="https://cdn.jsdelivr.net/gh/YSYin/YLogCDN/img/20210204154626.png" alt="本地版本控制系统架构" /></p><p>本地版本控制系统大多采用某种简单的数据库来记录文件的历次更新差异，其中最流行的一种叫做***RCS***，它的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。</p><h3 id="集中化版本控制系统"><a class="markdownIt-Anchor" href="#集中化版本控制系统"></a> 集中化版本控制系统</h3><p>集中化版本控制系统<strong>CVCS</strong>，如<strong>CVS</strong>、<strong>Subversion</strong>、<strong>Perforce</strong>都有一个单一的集中管理的服务器，保存所有文件的修订版本，协同工作的使用者都通过客户端连接到这台服务器，取出最新的文件或者提交更新。</p><p>集中化版本控制系统一定程度上满足了用户协同工作的需求，而且管理员也可以轻松掌控每个开发者的权限，并且管理一个CVCS要远比在各个客户端上维护本地数据库更加易于实现；另一方面，CVCS高度依赖于中心服务器的管理，如果中心服务器发生故障，则所有用户都不能提交更新、协同工作；若中心服务器发生数据损坏或丢失，又没有做恰当备份，则项目的所有数据、包括变更历史都将丢失且不可恢复，只留下用户各自机器上过去保留的快照。</p><p><img src="https://cdn.jsdelivr.net/gh/YSYin/YLogCDN/img/20210204160339.png" alt="集中化版本控制系统" /></p><h3 id="分布式版本控制系统"><a class="markdownIt-Anchor" href="#分布式版本控制系统"></a> 分布式版本控制系统</h3><p>面对CVCS的限制和不足，分布式版本控制系统<strong>DVCS</strong>应运而生，在DVCS，如<strong>Git</strong>、<strong>Mercurial</strong>、<strong>Bazaar</strong>、<strong>Darcs</strong>中，客户端不只提取最新版本的文件快照，而是把代码仓库完整的镜像下来，因此，即使任一处服务器发生故障，事后都可以用任意一个镜像出来的本地仓库恢复。</p><p><img src="https://cdn.jsdelivr.net/gh/YSYin/YLogCDN/img/20210204160834.png" alt="分布式版本控制系统" /></p><h2 id="git简史"><a class="markdownIt-Anchor" href="#git简史"></a> Git简史</h2><p>Linux内核开源项目自2002开始使用一个专有的分布式版本控制系统BitKeeper来管理和维护代码，到2005年，BitKeeper收回了Linux内核社区免费使用BitKeeper的权力，使得Linux的缔造者Linus Torvalds 基于使用BitKeeper的经验教训，开发出一套开源的分布式版本系统——Git。</p><h2 id="git核心"><a class="markdownIt-Anchor" href="#git核心"></a> Git核心</h2><p>与其他版本控制系统相比，Git在保存和处理信息方面有着独特的方式。</p><ol><li><p>直接记录快照，而非差异比较</p><p>大部分系统以文件变更列表的方式存储信息，将它们保存的信息看做是一组基本文件和每个文件随时间逐步累积的差异。Git则把数据看做是对小型文件系统的一组快照，每次提交更新、或是保存状态时，Git会对当时的全部文件制作一个快照并保存这个快照的索引，为了高效，如果文件没有修改，Git不再重新存储该文件，而只是保留一个链接指向之前存储的文件。Git对待数据更像是一个<strong>快照流</strong>。</p></li><li><p>近乎所有操作都是本地执行</p><p>在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其他计算机的信息，因此相比于CVCS在速度和用户体验上都更加优越。此外，即使在离线或者没有VPN时，本地计算机也能进行几乎所有操作：查看项目全部历史、修改项目文件、提交修改。</p></li><li><p>Git保证完整性</p><p>Git中所有数据在存储前都计算校验和，然后以校验和来引用数据。因此，如果在传送过程中丢失信息或者损坏文件，Git都能及时的检测和发现。Git使用SHA-1散列计算校验和，产生一个由40个十六进制字符(0-9和a-f)组成的字符串，散列基于的数据是文件中的内容或目录结构。在Git数据库中，保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p></li><li><p>Git一般只添加数据</p><p>几乎所有Git操作都只往Git数据库中添加数据，很难让Git执行任何不可逆操作，或者让它以任何方式清除数据。一旦提交快照到Git中，就很难再丢失数据。</p></li><li><p>Git的三种状态</p><p>在Git中，文件存在三种状态：已提交(committed)、已修改(modified)、已暂存(staged)。</p><ul><li>已提交表示数据已经安全的保存在本地数据库中</li><li>已修改表示修改了文件，但还没有保存到数据库中</li><li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li></ul><p>文件的三种状态对应Git的三个工作区域：Git仓库、工作目录、暂存区域</p><ul><li>Git仓库目录是Git用来保存项目的元数据和对象数据库的地方（克隆仓库时，复制的就是这里的数据，一般为<code>.git</code>隐藏目录）</li><li>工作目录是对项目的某个版本独立提取出来的内容，以供用户使用或修改</li><li>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般位于Git仓库目录中</li></ul><p>基本的Git工作流程是：</p><ul><li>在工作目录中修改文件</li><li>暂存文件，将文件的快照放入暂存区域</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录</li></ul></li></ol><h2 id="git起步"><a class="markdownIt-Anchor" href="#git起步"></a> Git起步</h2><p>在系统安装Git后，通过<code>git init</code>即可创建一个Git仓库，然后需要立即进行相关配置，定制个人的Git环境。</p><h3 id="git配置文件"><a class="markdownIt-Anchor" href="#git配置文件"></a> Git配置文件</h3><p><code>git config</code>命令用于设置控制Git外观和行为的配置变量，这些变量存储在三个位置</p><ul><li>第一级别——<code>/etc/gitconfig</code>文件：包含系统上每一个用户及其所有仓库的通用配置，通过使用<code>--system</code>选项选择从该文件中设置配置变量</li><li>第二级别——<code>~/.gitconfig或~/.config/git/config</code>文件：系统当前用户及所有仓库的配置，通过使用<code>--global</code>选项选择从该文件中设置配置变量</li><li>第三级别——当前Git仓库目录中的<code>.git/config</code>文件：当前用户的当前使用仓库的配置</li></ul><p>自上而下，下级配置会覆盖上级配置，故<code>.git/config</code>是最有效力的配置文件</p><h3 id="git配置变量"><a class="markdownIt-Anchor" href="#git配置变量"></a> Git配置变量</h3><h4 id="用户信息"><a class="markdownIt-Anchor" href="#用户信息"></a> 用户信息</h4><p>用户名称和邮件地址是Git配置的最首要的一步，因为用户信息会写到用户的每一次提交中，而且不可更改。配置用户名称和邮件地址的命令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;John Doe&quot;</span><br><span class="line">git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure><p>如前所述，通过使用<code>--global</code>参数，这两条命令配置的用户信息会自动应用到该系统用户的所有Git仓库，除非他在某一个Git仓库中重新进行第三级别的配置</p><h4 id="文本编辑器"><a class="markdownIt-Anchor" href="#文本编辑器"></a> 文本编辑器</h4><p>Git中某些操作需要输入文本内容，因此需要通过文本编辑器打开，默认情况下，Git使用Vim，通过<code>core.editor</code>属性，用户可以配置文本编辑器，在Windows下，若想使用sublime text打开，则可进行如下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.editor &quot;D:/&#x27;Sublime Text 3&#x27;/sublime_text.exe -n -w&quot;</span><br></pre></td></tr></table></figure><h3 id="检查配置信息"><a class="markdownIt-Anchor" href="#检查配置信息"></a> 检查配置信息</h3><p>通过<code>git config --list</code>命令可以列出Git当时能找到的全部配置，包括三个级别的全部配置信息</p><p>通过<code>git config &lt;key&gt;</code>命令可以返回Git的某一项配置</p><h3 id="帮助"><a class="markdownIt-Anchor" href="#帮助"></a> 帮助</h3><p>通过3种方式可以找到Git命令的使用手册</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git help &lt;verb&gt;</span><br><span class="line">git &lt;verb&gt; --help</span><br><span class="line">man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure><h2 id="git基础"><a class="markdownIt-Anchor" href="#git基础"></a> Git基础</h2><h3 id="创建git仓库"><a class="markdownIt-Anchor" href="#创建git仓库"></a> 创建Git仓库</h3><p>在Git中，有两种方式创建一个Git仓库。</p><ol><li><p>在现有目录中初始化仓库</p><p>通过执行<code>git init</code>命令，Git会在当前目录中创建<code>.git</code>子目录，该子目录包含一个Git仓库所需的全部文件，是仓库的骨干。</p></li><li><p>克隆已有的仓库</p><p>通过执行<code>git clone [url]</code>命令，Git会将该url表示的仓库克隆到本地，注意，克隆的是原仓库的全部版本和文件，而不仅仅是某一个特定版本；Git支持多种数据传输协议：包括HTTPS、GIT、SSH</p></li></ol><h3 id="添加文件"><a class="markdownIt-Anchor" href="#添加文件"></a> 添加文件</h3><p>如前所述，Git中文件存在三种状态：已提交、已修改、已暂存；事实上，这三种状态的前提是该文件已经被纳入Git管理；在这三种状态的上一层次上，工作目录中的每一个文件实际上不外乎两种状态：已跟踪和未跟踪。</p><ul><li>已跟踪的文件：纳入版本控制管理，要么之前被提交过，要么正处于暂存区</li><li>未跟踪的文件：不存在上次快照的记录中、也不在寄存区中 、或者通过命令删除</li></ul><p>通过<code>git status</code>命令，我们可以方便的查看当前工作目录内全部的文件状态</p><p>通过<code>git status -s或者--short</code>命令，可以得到输出的紧凑版格式，其中</p><ul><li><code>??</code>表示未跟踪文件</li><li><code>A</code>表示<strong>新</strong>添加到暂存区域</li><li>左侧<code>M</code>表示文件已修改且放入暂存区域</li><li>右侧<code>M</code>表示文件已修改但还未放入暂存区域</li></ul><p>通过<code>git add</code>命令，可以将一个未跟踪的文件变为跟踪状态、并处于暂存状态；同时也可以将一个已追踪且修改的文件状态转为暂存状态；总体来说，<code>git add</code>命令将文件添加到下一次提交的暂存区域中</p><h3 id="忽略文件"><a class="markdownIt-Anchor" href="#忽略文件"></a> 忽略文件</h3><p>默认情况下，Git输出工作目录内的全部文件信息，包括已追踪和未追踪文件；为了将某些文件彻底被Git忽略（即不出现在未追踪文件中），可以创建一个<code>.gitignore</code>文件，列出要忽略的文件模式（正则匹配），<code>.gitignore</code>的格式规范如下</p><ul><li>所有空行或者以<code>#</code>开头的行都会被Git忽略</li><li>可以使用标准的glob模式匹配<ul><li>一个星号<code>*</code>匹配<strong>零个或多个</strong>任意字符</li><li><code>[abc]</code>匹配任何<strong>一个</strong>方括号中的字符，可以使用连字符-表示范围</li><li><code>?</code>只匹配<strong>一个</strong>任意字符</li><li>两个星号<code>**</code>表示匹配任意(零或多个)中间目录</li></ul></li><li>匹配模式可以以<code>/</code>开头防止递归</li><li>匹配模式可以以<code>/</code>结尾指定目录</li><li>匹配模式前加上<code>!</code>表示取反</li></ul><h3 id="提交更新"><a class="markdownIt-Anchor" href="#提交更新"></a> 提交更新</h3><p>通过命令<code>git commit</code>，Git会将暂存区域中的文件提交，同时启动文本编辑器（即之前通过<code>git config core.editor</code>设置的配置变量）以便输入本次提交的<strong>说明</strong>；打开后文本编辑器会以注释的方式显示本次变动的文件有哪些（通过<code>-v</code>选项可以显示本次变动的行有哪些）</p><p>通过添加<code>-m</code>选项，可以将提交信息与命令放在同一行，不必打开文本编辑器</p><p><strong>每一次运行提交操作，都是对项目做一次快照</strong>，以后可以回到这个状态，或者进行比较</p><p>通过添加<code>-a</code>选项，Git会自动把所有已经跟踪过的文件暂存起来一并提交；即此时提交的是工作目录中的最新文件；这个选项对于我们多次手动删除文件，却忘记通过<code>git rm</code>命令在Git中删除很有帮助，因为Git会自动把这些已经删除的文件标记为删除，而不是将其作为“已修改未暂存”状态</p><h3 id="删除文件"><a class="markdownIt-Anchor" href="#删除文件"></a> 删除文件</h3><p>通过命令<code>git rm</code>，Git会将文件从已跟踪列表（确切地说，是暂存区域）中删除，具体来说，有以下几种情况</p><ul><li>对于已经提交的文件，未修改时，通过<code>git rm</code>命令可以将文件从暂存区域和工作目录中删除</li><li>手工删除文件后，直接通过<code>git rm &lt;file&gt;</code>删除，则Git不再追踪；否则，文件处于已更新未暂存</li><li>对于修改且暂存的文件，通过<code>git rm -f &lt;file&gt;</code>，将文件强制从工作目录中删除，并不再追踪</li><li>通过<code>git rm --cached &lt;file&gt;</code>，将文件从暂存区域中删除，但仍保留在工作目录中，文件处于未跟踪状态</li></ul><h3 id="移动文件"><a class="markdownIt-Anchor" href="#移动文件"></a> 移动文件</h3><p>通过<code>git mv</code>命令，实现文件的移动（或重命名）</p><p>实际上，Git并不追踪文件的移动操作，<code>git mv</code>命令相当于三条命令的组合：<code>mv+rm+add</code></p><h3 id="查看提交历史"><a class="markdownIt-Anchor" href="#查看提交历史"></a> 查看提交历史</h3><p>通过<code>git log</code>命令，可以查看仓库的全部提交历史，默认情况下，会按提交时间列出所有的更新，最近的更新排在最上面，列出的信息包括每个提交的SHA-1校验和、作者名字和邮件地址、提交时间和提交说明</p><p>通过添加一些选项，可以获得更加详细的历史信息</p><ul><li><code>-p</code>选项可以显示每次提交的内容差异</li><li><code>-2</code>选项可以显示最近两次提交</li><li><code>--since=2.weeks</code>：两周以来的提交</li><li><code>--until=2.weeks</code>：两周之前的提交</li><li><code>--author</code>：指定作者</li><li><code>--grep=word</code>：搜索提交说明的关键字</li><li><code>-Sword</code>：仅显示添加或删除word的提交</li><li><code>--stat</code>选项可以输出统计信息：多少文件被修改、哪些行被移除或添加</li><li><code>--pretty=style</code>选项指定特定格式显示提交历史，其中style可以是<ul><li>oneline：每个提交放在一行</li><li>format:&quot;%s%H&quot;：通过定制format字符串显示内容<ul><li>%H：提交的完整哈希字符串</li><li>%h：提交的简短哈希字符串</li><li>%an：作者名字</li><li>%ae：作者email</li><li>%ad：作者修订日期</li><li>%ar：作者修订日期，按多久以前的方式显示</li><li>%cn：提交者的名字</li><li>%ce：提交者电子邮件</li><li>%cd：提交日期</li><li>%cr：提交日期</li><li>%s：提交说明</li></ul></li></ul></li><li><code>--graph</code>选项形象的展示出分支和合并历史</li></ul><p><img src="https://cdn.jsdelivr.net/gh/YSYin/YLogCDN/img/20210206131012.png" alt="git log的常用选项一" /></p><p><img src="https://cdn.jsdelivr.net/gh/YSYin/YLogCDN/img/20210206131605.png" alt="git log的常用选项二" /></p><h3 id="撤销操作"><a class="markdownIt-Anchor" href="#撤销操作"></a> 撤销操作</h3><p>在Git中，有少数几个可以撤销操作的地方：</p><ul><li>在刚刚提交完之后，若发现存在某些文件没有添加或者提交信息写错，可以在添加完文件后，通过<code>git commit --amend</code>选项进行补充提交，这次提交会覆盖之前的提交</li><li>通过<code>git reset HEAD &lt;file&gt;</code>命令或者<code>git restore --staged &lt;file&gt;</code>可以取消已经处在暂存区的文件，该文件变为已修改未暂存的装填</li><li>通过<code>git checkout -- &lt;file&gt;</code>命令可以将前一次提交的file覆盖到当前工作目录中的文件</li></ul><p><strong>注意：在Git中任何已提交的东西几乎总是可以被恢复，但是任何未提交的内容很可能永久丢失</strong></p><h3 id="远程仓库"><a class="markdownIt-Anchor" href="#远程仓库"></a> 远程仓库</h3><p>远程仓库是指托管在因特网或其他网络中的项目的版本库，与他人协作涉及推送或拉取数据。</p><ul><li>通过<code>git remote</code>命令，可以输出每一个远程服务器的简写，通过克隆操作建立联系的远程仓库的默认名字是<code>origin</code><ul><li>添加<code>-v</code>选项后，会显示出远程仓库的URL</li><li>通过<code>git remote add &lt;shortname&gt; &lt;url&gt;</code>命令可以添加一个新的远程Git仓库，并指定简写</li><li>通过远程服务器的简写可以替代其URL</li><li>通过<code>git remote show &lt;sn&gt;</code>可以查看一个远程仓库的全部信息</li><li>通过<code>git remote rename &lt;old-n&gt; &lt;new-n&gt;</code>可以重命名远程仓库</li><li>通过<code>git remote rm &lt;sn&gt;</code>可以删除远程仓库</li></ul></li><li>通过<code>git fetch &lt;remote-name&gt;</code>命令可以从远程仓库获取数据，包括<strong>所有分支</strong>的引用和数据</li><li>通过<code>git push &lt;remote-name&gt; &lt;branch-name&gt;</code>命令可以将本地分支推送到远程服务器<ul><li>这条命令的前提是具有写入权限且之前无人推送，否则需要先将分支拉取、合并后再推送</li></ul></li></ul><h3 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> 标签</h3><p>Git可以给某一个提交打上标签，以作提示或者标记发布节点/版本。</p><ul><li>通过<code>git tag</code>命令列出所以已有的标签</li></ul><p>在Git中，存在两种标签：轻量标签和附注标签</p><ul><li>轻量标签：只是一个特定提交的<strong>引用</strong><ul><li>通过<code>git tag tag-name</code>创建轻量标签</li></ul></li><li>附注标签：一个完整对象，可被校验，包含打标签者的名字、电子邮件地址、日期时间和标签信息，还可以通过GPG(GNU Privacy Guard)签名与验证<ul><li>通过<code>git tag -a tag-name -m tag-desc</code>命令创建一个附注标签</li><li>通过<code>git tag -a tag-name -m tag-desc checksum</code>对历史的提交打标签，需要提供校验和或部分校验和</li><li>通过<code>git show tag-name</code>查看标签信息和对应的提交信息</li></ul></li></ul><p>默认情况下，<code>git push</code>命令不会将标签传送到远程服务器，通过<code>git push sn tag-name</code>显式推送标签到共享服务器，或者使用 --tags推送全部标签信息</p><h3 id="别名"><a class="markdownIt-Anchor" href="#别名"></a> 别名</h3><p>Git不会自动推断你输入的命令，为了提高效率，可以通过<code>git config</code>命令为每一个命令设置别名</p><ul><li><code>git config --global alias.co checkout</code>，则<code>git co相当于git commit</code></li><li><code>git config --global alias.unstage 'reset HEAD --'</code>，则<code>git unstage</code>可以取消暂存</li><li><code>git config --global alias.visual '!gitk'</code>，命令前加!表示不是Git子命令，是外部命令</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工具技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    
    
    <entry>
      <title>排序：经典算法</title>
      <link href="%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E6%8E%92%E5%BA%8F%EF%BC%9A%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
      <url>%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E6%8E%92%E5%BA%8F%EF%BC%9A%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>排序是将一组对象按照某种逻辑顺序重新排列的过程。在计算时代早期，据估计有30%的计算周期都用在排序上，排序在商业数据处理和现在科学计算中都有着很重要的地位，能够应用于事务处理、组合优化、天体物理学、分子动力学、语言学、基因组学、天气预报和很多其他领域，快速排序甚至被誉为20世纪科学和工程领域的十大算法之一。本文主要参考由<strong>Robert Sedgewick、Kevin Wayne</strong>所著、<strong>谢路云</strong>所译的<strong>Algorithms</strong>(第4版)，将讨论比较排序算法的理论基础、若干算法和优先队列。</p><h2 id="初级排序算法"><a class="markdownIt-Anchor" href="#初级排序算法"></a> 初级排序算法</h2><h3 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h3><p>选择排序算法采用如下逻辑进行排序：首先，找到数组中最小的元素，然后将它和数组中的第一个元素交换位置；再次，在剩下的元素中找到最小的元素，将它和数组的第二个元素交换位置，如此往复，直到将整个数组排序，选择排序的C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = a.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> minPos = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; ++j)</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; a[minPos]) minPos = j;</span><br><span class="line">swap(a[i], a[minPos]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序具有如下的特点：</p><ul><li><p>运行时间和输入分布无关</p><p>无论输入初始是什么状态，是否有序是否反序，选择排序的运行时间并无区别。无论输入为何，选择排序总要运行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mn>1</mn><mo>=</mo><mfrac><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>∼</mo><mfrac><msup><mi>N</mi><mn>2</mn></msup><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">(N-1)+(N-2)+...+1=\frac{N(N-1)}{2}\sim\frac{N^2}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.36292em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>次比较操作和N次交换操作</p></li><li><p>元素移动次数是最少的</p><p>如前所述，选择排序共进行N次交换操作，而之后可以看到，其他算法的元素移动次数都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mtext> </mtext><mi>o</mi><mi>r</mi><mtext> </mtext><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">NlogN\space or\space N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace"> </span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>级别的</p></li></ul><p>根据算法分析可知，选择排序要进行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{N(N-1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>次的比较和N次的移动，总时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，总空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h3 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h3><p>插入排序基于如下逻辑进行：将每个元素插入到已经排序的子序列中的适当位置。同时，为了给要插入的元素腾出空间，需要将其余所有元素都在插入之前向右移动一位，插入排序的C++实现如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = a.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; --j)</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; a[j - <span class="number">1</span>])</span><br><span class="line">swap(a[j], a[j - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与选择排序不同，插入排序依赖于输入的状态，如果输入已经有序或接近有序，插入排序算法实际上只需要进行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>次的比较操作和常数次的移动操作。</p><p><strong>逆序对</strong>是指数组中两个顺序颠倒的元素，即大元素在小元素之前，如果数组中逆序对的数量小于数组大小的某个倍数，那么该数组就是部分有序的，如以下几种</p><ul><li>数组中每个元素距它的最终位置不远</li><li>一个有序的大数组接一个小数组</li><li>数组中只有几个元素的位置不正确</li></ul><p>由插入排序算法可知，算法每次的比较和交换都消除了数组中的一个逆序对，设数组中逆序对的数量为R，则插入排序的元素交换次数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>次，元素比较次数的范围是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>R</mi><mo separator="true">,</mo><mi>R</mi><mo>+</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[R, R+N-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，而逆序对数量R的取值范围为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mfrac><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,\frac{N(N-1)}{2}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span>，因此在平均情况下，插入排序需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∼</mo><mfrac><msup><mi>N</mi><mn>2</mn></msup><mn>4</mn></mfrac></mrow><annotation encoding="application/x-tex">\sim\frac{N^2}{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.36292em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>次比较和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∼</mo><mfrac><msup><mi>N</mi><mn>2</mn></msup><mn>4</mn></mfrac></mrow><annotation encoding="application/x-tex">\sim\frac{N^2}{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.36292em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>次交换，在最坏情况下，需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∼</mo><mfrac><msup><mi>N</mi><mn>2</mn></msup><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\sim\frac{N^2}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.36292em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>次比较和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∼</mo><mfrac><msup><mi>N</mi><mn>2</mn></msup><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\sim\frac{N^2}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.36292em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>次交换，在最好情况下，需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>次比较和0次交换。</p><p>总的来说，插入排序对于部分有序的数组十分高效，也很适合小规模数组，对于逆序对数量很少的输入，插入排序很可能比其他任何算法都快。</p><p>对插入排序一个简单而有效的改进是，每次不交换<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mi mathvariant="normal">和</mi><mi>a</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a[j]和a[j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mord cjk_fallback">和</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>的值，而是把大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>的值右移一位，通过这种改进可以使得访问数组的次数减半。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSortX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = a.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> vi = a[i];</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; vi &lt; a[j - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">--j;</span><br><span class="line">&#125;</span><br><span class="line">a[j] = vi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，插入排序的时间复杂为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，总空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h3 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h3><p>希尔排序是一种基于插入排序改进的快速的排序算法。由前面对插入排序的分析可以知道，插入排序对每一个逆序对都需要进行一次比较和一次交换/移动操作，也就是说，插入排序中一次比较和一次交换/移动操作只能消除序列中的一个逆序对，那么一个直接的想法就是：可不可以通过一次比较和一次交换/移动操作消除序列中多个逆序对呢？希尔排序就做到了这一点。</p><p>希尔排序的思想是使数组中任意间隔为h的元素都是有序的，这样的数组称为h有序数组，一个h有序数组就是h个互相独立的有序数组编织在一起形成的一个数组，在进行排序时，如果h很大，我们就能将元素移动到很远的地方，实现一次消除若干逆序对的目标，对于任意以1结尾的h序列，我们都能够将数组排序。</p><p><img src="https://cdn.jsdelivr.net/gh/YSYin/YLogCDN/img/20210128123604.png" alt="h有序数组" /></p><p>希尔排序的C++实现如下所示，这里使用的h序列是[1, 4, 13, 40, 121, 364, …]：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = a.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (h &lt; N / <span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h; j -= h)</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; a[j - h])</span><br><span class="line">swap(a[j], a[j - h]);</span><br><span class="line">h /= <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与希尔排序性能密切相关的因素是h递增序列。目前尚无法确定哪一种h递增序列是最佳的序列，对希尔排序进行准确的数学分析是十分困难和繁杂的，但有一点可以确定，对于我们实现的希尔排序算法，它的时间复杂度不到平方级别，研究表明最坏情况下其比较次数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mfrac><mn>3</mn><mn>2</mn></mfrac></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^{\frac{3}{2}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.20402em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9540200000000001em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>由上，我们实现的希尔排序的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mfrac><mn>3</mn><mn>2</mn></mfrac></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^{\frac{3}{2}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.20402em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9540200000000001em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h2 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h2><p>归并排序是基于分治思想的一种排序算法，简单，但有效，成功地将排序的比较操作降低到nlogn量级，尽管其代价是需要和 N成正比的额外空间。</p><p>归并算法的思想十分简单，即将两个有序的数组顺序遍历归并成一个更大的有序数组。首先将一个数组（递归地）分成两半并分别排序，然后将结果归纳出来，归并排序的C++实现如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; ++k)</span><br><span class="line">aux[k] = a[k];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; ++k)</span><br><span class="line"><span class="keyword">if</span> (i &gt; mid) a[k] = aux[j++];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) a[k] = aux[i++];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &lt; aux[j]) a[k] = aux[i++];</span><br><span class="line"><span class="keyword">else</span> a[k] = aux[j++];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">mergeSort(a, aux, lo, mid);</span><br><span class="line">mergeSort(a, aux, mid + <span class="number">1</span>, hi);</span><br><span class="line">merge(a, aux, lo, mid, hi);</span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = a.<span class="built_in">size</span>();</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">aux</span><span class="params">(N, <span class="number">0</span>)</span></span>;</span><br><span class="line">mergeSort(a, aux, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种自顶向下的递归实现方式，需要额外的数组aux用于归并操作，空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，可以证明，至少需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mi mathvariant="normal">到</mi><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">\frac{1}{2}NlogN到NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">到</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>次比较操作，访问数组次数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mi mathvariant="normal">到</mi><mn>6</mn><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">4NlogN到6NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">到</span><span class="mord">6</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>次，由此，归并排序的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p><p>归并排序算法将排序的时间复杂度降低到了线性对数级别，尽管如此，仍然通过某些技巧进一步降低归并排序的运行时间。</p><h3 id="小规模数组采用插入排序"><a class="markdownIt-Anchor" href="#小规模数组采用插入排序"></a> 小规模数组采用插入排序</h3><p><strong>用不同的方法处理小规模问题能改进大多数递归算法的性能，因为递归会使得小规模问题中方法的调用过于频繁，所以改进对它们的处理方法就能改进整个算法。</strong></p><p>之前，我们已经知道插入排序在小规模数组上的高效性，实践证明，使用插入排序处理小规模子数组（比如长度小于15）一般可以将归并排序的运行时间缩短10%~15%</p><h3 id="测试数组是否有序"><a class="markdownIt-Anchor" href="#测试数组是否有序"></a> 测试数组是否有序</h3><p>可以添加一个判断条件，如果a[mid]≤a[mid+1]，我们就认为数组已经是有序的，从而跳过merge方法，通过这个调整，可以将任意有序的子数组算法的运行时间变为O(N)</p><h2 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h2><p>快速排序被誉为20世纪科学和工程领域的十大算法之一，它实现简单、适用于各种不同的输入数据而且在一般应用中比其他排序算法快得多，快速排序是原地排序（只需要一个很小的辅助栈），且时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>级别。</p><p>快速排序是一种分治的排序算法，主要实现逻辑是：切分+排序，即使用数组中的某个元素将数组划分为两部分，左半部分都比该元素小，右半部分都比该元素大，然后对左半部分和右半部分分别如此处理，直到子数组中元素数量为1，快速排序的C++实现如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> v = a[lo];</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (a[++i] &lt; v) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">while</span> (a[--j] &gt; v) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">swap(a[i], a[j]);</span><br><span class="line">&#125;</span><br><span class="line">swap(a[lo], a[j]);</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> j = partition(a, lo, hi);</span><br><span class="line">quickSort(a, lo, j - <span class="number">1</span>);</span><br><span class="line">quickSort(a, j + <span class="number">1</span>, hi);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = a.<span class="built_in">size</span>();</span><br><span class="line">quickSort(a, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从归并排序的实现可以发现，在切分<code>partition</code>操作的内循环中，只需要将数组元素和一个定值进行比较即可，这种短小的内循环是快速排序优良性能的原因之一，事实上，归并排序和希尔排序一般都比快速排序慢，其原因就是它们还在内循环中移动数据。</p><p>显然，快速排序的效率取决于划分的效果，但平均情况下，快速排序需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∼</mo><mn>2</mn><mi>N</mi><mi>l</mi><mi>n</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">\sim2NlnN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>次比较，以及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∼</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mi>N</mi><mi>l</mi><mi>n</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">\sim\frac{1}{3}NlnN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>次交换操作，最坏情况下，快速排序需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∼</mo><mfrac><msup><mi>N</mi><mn>2</mn></msup><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\sim\frac{N^2}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.36292em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>次比较操作，但通过随机打乱数组能够预防这种情况，事实上，快速排序处在最坏情况下的概率极小，例如，对于一个有着100万个元素的数组，其快排运行时间是平均所需时间的10倍的概率低于0.00001，对于大数组，运行时间是平方级别的概率可以忽略不计。</p><p>快速排序和归并排序都是时间复杂度达到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>级别的排序算法，二者都是分治算法的典型应用。分治算法的两大核心步骤是分和并：归并排序的关键操作在于并，分则按照数组长度对半自然划分；快速排序的关键操作在于分，并则将排序结果自然合并。在时间复杂度上，尽管快速排序的平均比较次数比归并排序多<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>39</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">39\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">3</span><span class="mord">9</span><span class="mord">%</span></span></span></span>，但是它移动数据的次数更少，一般情况下，快速排序都要快于归并排序；在空间复杂度上，快速排序是一种原地排序，不需要额外的空间，归并排序则需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>的空间进行归并；总体而说，快速排序是一种接近最优的排序方法。</p><h3 id="快速排序的改进"><a class="markdownIt-Anchor" href="#快速排序的改进"></a> 快速排序的改进</h3><p>自Hoare第一次发表快速排序算法开始，人们就不断提出各种改进方法，有些改进带来的提高可能会被意外的副作用所抵消，但有些改进也在一定程度上提升了快排的性能，下面介绍的几种改进方法一般能将排序性能提升<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn><mi mathvariant="normal">%</mi><mo>∼</mo><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">20\%\sim30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">%</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">%</span></span></span></span></p><ul><li><p>小规模数组时采用插入排序而不是快速排序</p></li><li><p>三取样切分</p><p>切分数组中，取样3个元素，用中位数作为切分元素进行划分</p></li><li><p>三向切分</p><p>对于大量重复元素的数组，可以采用三向切分的方式进行快速排序：将数组切分为三部分，分别对应于小于、等于和大于切分元素的数组元素，三向切分的C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort3Way</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> lt = lo, i = lo + <span class="number">1</span>, gt = hi;</span><br><span class="line"><span class="keyword">int</span> v = a[lo];</span><br><span class="line"><span class="keyword">while</span> (i &lt;= gt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; v) swap(a[lt++], a[i++]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; v) swap(a[i], a[gt--]);</span><br><span class="line"><span class="keyword">else</span> ++i;</span><br><span class="line">&#125;</span><br><span class="line">quickSort(a, lo, lt - <span class="number">1</span>);</span><br><span class="line">quickSort(a, gt + <span class="number">1</span>, hi);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="优先队列"><a class="markdownIt-Anchor" href="#优先队列"></a> 优先队列</h2><p>许多应用程序需要处理有序的元素，但不需要他们全部有序，或者不需要一次就将他们排序，很多情况下，我们只需要处理当前键值最大的元素，并且可能还需要随时收集更多的元素，然后再处理此时键值最大的元素。在这种情况下，一个合适的数据结构应该支持两种操作：返回(或同时删除)最大元素、插入元素，这种数据类型就叫做优先队列。</p><p>数据结构二叉堆能很好的实现优先队列的基本操作，在二叉堆的数组中，每个元素都要保证大于等于另两个特定位置的元素，相应地，这些位置的元素又至少要大于等于数组中的另两个元素，以此类推。对于一个二叉树来说，如果二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序，在这种情况下，根结点是堆有序的二叉树的最大结点。</p><p>在存储二叉堆时，如果使用指针表示结点的父子关系，那么每个结点都需要三个指针进行存储；而根据完全二叉树的性质，当我们把完全二叉树存储到数组中时，实际上通过数组索引即可表示结点的父子关系，由此，我们使用数组存储二叉堆，并将二叉堆定义为：一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组中的第一个位置/索引为0）</p><p>易得，在二叉堆中，位置k的结点的父结点的位置为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mi>k</mi><mn>2</mn></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor\frac{k}{2}\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span>，它的两个子结点的位置分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>k</mi><mi mathvariant="normal">和</mi><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2k和2k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">和</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>在对二叉堆进行上述的两种操作时，我们采用的步骤是：改动堆并打破堆的状态+遍历堆并按要求将堆的状态恢复，这个过程叫做堆的有序化。</p><p>堆的有序化对应两种类型的操作</p><ul><li>当某个结点的优先级上升（或是在堆底加入一个新的元素）时，由下至上的恢复堆的顺序</li><li>当某个结点的优先级下降（如将根结点替换为一个较小的元素）时，由上至下的恢复堆的顺序</li></ul><h3 id="由下至上的堆有序化上浮"><a class="markdownIt-Anchor" href="#由下至上的堆有序化上浮"></a> 由下至上的堆有序化/上浮</h3><p>如果堆的有序状态因为某个结点变得比父结点更大而被打破，则需要交换它和它的父结点，逐步上溯，直到有序状态恢复</p><h3 id="由上至下的堆有序化下沉"><a class="markdownIt-Anchor" href="#由上至下的堆有序化下沉"></a> 由上至下的堆有序化/下沉</h3><p>如果堆的有序状态因为某个结点变得比子结点更小而被打破，则需要将它和它的两个子结点中的较大者交换来恢复堆，逐步下行，直到有序状态恢复</p><p>根据这两种调整方式，我们可以进行插入元素和返回(或同时删除)最大元素：插入元素时，将新元素加到数组末尾，增加堆的大小并将该元素上浮到合适的位置；删除最大元素时，将数组最后一个元素覆盖到数组第一个元素(即根结点)，减少堆的大小并将该元素下沉到合适的位置，由上，二叉堆实现的优先队列的C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MaxPQ(<span class="keyword">int</span> maxN)</span><br><span class="line">&#123;</span><br><span class="line">N = <span class="number">0</span>;</span><br><span class="line">pq.resize(maxN + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; pq[k / <span class="number">2</span>] &lt; pq[k])</span><br><span class="line">&#123;</span><br><span class="line">swap(pq[k / <span class="number">2</span>], pq[k]);</span><br><span class="line">k /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line"><span class="keyword">if</span> (j &lt; N &amp;&amp; pq[j] &lt; pq[j + <span class="number">1</span>]) j++;</span><br><span class="line"><span class="keyword">if</span> (pq[k] &gt;= pq[j]) <span class="keyword">break</span>;</span><br><span class="line">swap(pq[k], pq[j]);</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pq[++N] = v;</span><br><span class="line">swim(N);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delMax</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = pq[<span class="number">1</span>];</span><br><span class="line">swap(pq[<span class="number">1</span>], pq[N--]);</span><br><span class="line">pq[N + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">sink(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据完全二叉堆的性质可以知道，二叉堆的树深至多为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，则由代码分析可知，插入操作至多需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">logN+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>次比较，删除最大元素至多需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">2logN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>次比较</p><h2 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h2><p>根据优先队列的性质，我们可以将优先队列变成一种排序方法，即将所有元素插入一个查找最小元素的优先队列，然后再重复调用删除最小元素的操作来将它们按顺序删去。</p><p>堆排序可以分为两个阶段。在堆的构造阶段中，将原始数组重新组织安排进一个堆中；在下沉排序阶段中，从堆中按递减顺序取出所有元素并得到排序结果。为了尽量减少堆的占用空间，我们使用原始数组作为堆的存储数组，从而无需任何额外空间。</p><h3 id="堆的构造"><a class="markdownIt-Anchor" href="#堆的构造"></a> 堆的构造</h3><p>在给定数组中构造堆的最简单的方式是从左至右逐元素插入到堆中，这个过程的时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。一种更高效的方法是从右至左用sink方法构造子堆：如果一个结点的两个子结点都已经是堆了，那么在该结点上调用sink方法可以将其变为一个堆。开始时，只需要扫描数组中的一半元素，因为可以跳过大小为1的子堆，然后依次处理大小为3的堆、大小为7的堆…最后在位置1上调用sink方法即可构建一个堆；堆排序的C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pq, <span class="keyword">int</span> k, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line"><span class="keyword">if</span> (j &lt; N &amp;&amp; pq[j] &lt; pq[j + <span class="number">1</span>]) j++;</span><br><span class="line"><span class="keyword">if</span> (pq[k] &gt;= pq[j]) <span class="keyword">break</span>;</span><br><span class="line">swap(pq[k], pq[j]);</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = a.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; --k)</span><br><span class="line">sink(a, k, N);</span><br><span class="line"><span class="keyword">while</span> (N &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">swap(a[<span class="number">1</span>], a[N--]);</span><br><span class="line">sink(a, <span class="number">1</span>, N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察可以得到，用下沉操作构建堆只需少于2N次比较以及少于N次的交换</p><p>在排序阶段，将堆的根结点和堆的最后一个结点交换位置，同时减少堆的大小，然后通过下沉操作将最后一个结点放到合适位置，同时得到新的最大元素，这个过程至多需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">2NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>次比较操作和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>次交换操作</p><p>综上，堆排序最坏情况下的比较次数是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>+</mo><mn>2</mn><mi>N</mi></mrow><annotation encoding="application/x-tex">2NlogN+2N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，交换次数是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>+</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN+N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></p><p><strong>堆排序在排序复杂性的研究中有着重要的地位，因为它是我们所知的唯一能够同时最优的利用空间和时间的方法——在最坏的情况下也能保证使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∼</mo><mn>2</mn><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">\sim2NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>次比较和恒定的额外空间。但在现代系统的许多应用很少使用它，这是因为它无法利用缓存，数组元素很少和相邻的其他元素进行比较，因此缓存未命中的次数要远远高于大多数在相邻元素间进行的算法，如快速排序、归并排序、希尔排序</strong></p><h2 id="排序问题的算法复杂度"><a class="markdownIt-Anchor" href="#排序问题的算法复杂度"></a> 排序问题的算法复杂度</h2><p>可以通过决策树证明，在以比较操作为基本操作的算法类中，任何排序算法至少需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo><mo>∼</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logN!)\sim O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">!</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>次比较操作，由此可见，归并排序、快速排序、堆排序已经是基于比较的排序算法的最优者。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>前述所有排序算法的性能特点如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YSYin/YLogCDN/img/20210203210702.png" alt="各种排序算法的性能特点" /></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
            <tag> 排序 </tag>
            
            <tag> 初级排序 </tag>
            
            <tag> 优先队列 </tag>
            
            <tag> 快速排序 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集UnionFind: 实现与优化</title>
      <link href="%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E5%B9%B6%E6%9F%A5%E9%9B%86UnionFind-%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/%E5%B9%B6%E6%9F%A5%E9%9B%86UnionFind-%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><p>假定输入一列整数对，其中每个整数都代表一个某种类型的对象，一对整数p和q可以被理解为：p和q是相连的，并且<strong>相连</strong>是一种等价关系，即满足自反性、对称性和传递性。等价关系将对象分为多个等价类，则问题是我们如何快速的对输入的新整数对进行判断：该整数对是否位于同一等价类，以及等价类的数目？</p><p>将这个问题转化到无向图中，将每个整数对应图中的一个节点，相连关系对应两个节点的一条边，则一个等价类就对应图中的一个<strong>连通分量</strong>，即图的一个极大连通子图，该子图内任意两个节点都能直接或间接相连，那么问题是如何快速判断两个节点是否位于一个连通分量中，以及连通分量的数目？</p><h2 id="api"><a class="markdownIt-Anchor" href="#api"></a> API</h2><p>将该问题抽象为一个数据结构类UF，其API设计如下</p><p><img src="https://cdn.jsdelivr.net/gh/YSYin/YLogCDN/img/20210125140609.png" alt="算法API" /></p><p>如上，我们需要定义一种数据结构表示已有的连接，基于该数据结构实现高效的union find等算法，我们可以使用一个<code>id</code>数组作为基本数据结构，使用节点标号作为索引，而<code>id</code>值则表示该节点所属的连通分量</p><h2 id="quick-find算法"><a class="markdownIt-Anchor" href="#quick-find算法"></a> quick-find算法</h2><p>直观上，我们可以通过保证当且仅当<code>id[p]</code>等于<code>id[q]</code>时，p和q是连通的，即同一个连通分量的所有节点的id值相同。这是一种quick-find的算法，因为我们只需要访问id数组一次就可以得到节点所在的连通分量标号，但是对于union操作来说，我们在合并两个连通分量P和Q时，必须遍历整个id数组，把其中指向P的节点改为指向Q，这是一个线性时间的操作</p><p>由上，我们可以得到find操作的时间复杂度为O(1), union操作的时间复杂度为O(n)</p><p>假设构建连通图的整数对有n个，查询连通图的整数对有n个，那么，整个过程的时间复杂度是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n*(O(1)+O(n))+n*(O(1))=O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>对于特别大的节点数量来说，这种复杂度是不可接受的。</p><h2 id="quick-union算法"><a class="markdownIt-Anchor" href="#quick-union算法"></a> quick-union算法</h2><p>在quick-find算法中，瓶颈在于union操作，每次合并连通分量时都需要遍历整个数组，为了减少遍历和修改的次数，我们重新定义id数组，每个节点所对应的id值都是该连通分量内另一个节点的名称，即id对应<strong>链接</strong>，如果一个节点的链接指向自己，那么该节点作为该连通分量的根节点，代表了该连通分量，一个连通分量内的全部节点实际上通过这种链接形成了一棵树。</p><p>由上，在find操作时，我们不断沿着节点的链接上溯，直到找到该连通分量的根节点，union操作时，我们首先调用find函数得到两个连通分量的根节点，然后将其中一个根节点指向另一个根节点即可。</p><p>设连通分量对应树的深度为d，则find操作的时间复杂度为O(d)，union操作的时间复杂度为O(d)</p><p>由于在合并连通分量时任意选择一个根节点指向另一个根节点，因此树的最大深度为n，在最坏情况下，find操作的时间复杂度为O(n)，union操作的时间复杂度也是O(n)</p><h2 id="加权quick-union算法"><a class="markdownIt-Anchor" href="#加权quick-union算法"></a> 加权quick-union算法</h2><p>在quick-union算法中，find和union操作的时间复杂度依赖于连通分量树的深度。为了控制树的最大深度，我们可以控制合并时的操作：总是让节点数少的树连接到节点数多的树上。增加新的数据结构sz数组记录每个连通分量的节点数目，在合并操作时，总是让节点数目大的根节点作为父节点，而另一个少的根节点作为子节点，以此控制数的最大深度。</p><p>可以证明，这种情况下树的最大深度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><p>由上，find操作的时间复杂度为O(logn)，union操作的时间复杂度为O(logn)，总时间复杂度为O(nlogn)</p><p>合并两个连通分量时，除了采用节点数目作为控制的<strong>权</strong>，我们也可以直接采用树的深度作为权。即在合并时，将深度小的树连接到深度大的树，如果深度相等，则任意连接，并将父节点的深度加一，可以证明，这种方式下树的最大深度也是logn</p><p>本人之见，两种加权方式（数量权和深度权）的区别在于</p><ul><li>union操作时，数量权每次都要改变，而深度权只有在两个深度相同时才需要改变</li><li>两种加权方式虽然都能保证树的最大深度不超过logn，但是数量权可以保证更多的节点处在更接近根节点的位置</li></ul><h2 id="带路径压缩的加权quick-union算法"><a class="markdownIt-Anchor" href="#带路径压缩的加权quick-union算法"></a> 带路径压缩的加权quick-union算法</h2><p>加权quick-union算法可以确保树的深度不超过logn，但我们也可以采取某种方式进一步压缩树的深度：find操作时路径压缩。</p><p>在执行find操作时，我们以往只是从节点不断上溯，直到找到根节点，上溯的步数为该节点所在的深度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>d</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">d&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>，赋值操作的数量也是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>d</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">d&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>，我们可以采取一种折半压缩的方式，每次上溯时，把节点的父节点修改为节点的祖父节点，然后从祖父节点继续上溯，这种方式下，树的深度会减少<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>d</mi><mo mathvariant="normal">′</mo></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">d&#x27;/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">2</span></span></span></span>，而上溯的步数也变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>d</mi><mo mathvariant="normal">′</mo></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">d&#x27;/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">2</span></span></span></span>，总赋值操作的数量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><msup><mi>d</mi><mo mathvariant="normal">′</mo></msup><mi mathvariant="normal">/</mi><mn>2</mn><mo>=</mo><msup><mi>d</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">2*d&#x27;/2=d&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></p><p>由上，此时find操作的时间复杂度非常接近O(1)，union操作的时间复杂度也非常接近O(1)，总时间复杂度非常接近O(n)</p><p>所有union-find算法的性能如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YSYin/YLogCDN/img/20210125140552.png" alt="算法性能" /></p><h2 id="带路径压缩的加深度权quick-union算法的c实现"><a class="markdownIt-Anchor" href="#带路径压缩的加深度权quick-union算法的c实现"></a> 带路径压缩的加(深度)权quick-union算法的C++实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">UF(<span class="keyword">int</span> N)</span><br><span class="line">&#123;</span><br><span class="line">count = N;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">parent.push_back(i);</span><br><span class="line">rank.push_back(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (p != parent[p])</span><br><span class="line">&#123;</span><br><span class="line">parent[p] = parent[parent[p]];</span><br><span class="line">p = parent[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionPQ</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pRoot = <span class="built_in">find</span>(p);</span><br><span class="line"><span class="keyword">int</span> qRoot = <span class="built_in">find</span>(q);</span><br><span class="line"><span class="keyword">if</span> (pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rank[pRoot] &lt; rank[qRoot]) id[pRoot] = qRoot;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rank[pRoot] &gt; rank[qRoot]) id[qRoot] = pRoot;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">id[pRoot] = qRoot;</span><br><span class="line">rank[qRoot] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">--count;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
            <tag> 并查集 </tag>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Project</title>
      <link href="%E6%8A%80%E6%9C%AF/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/LeetCode-Project/"/>
      <url>%E6%8A%80%E6%9C%AF/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/LeetCode-Project/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计划"><a class="markdownIt-Anchor" href="#计划"></a> 计划</h1><p>在150天之内，完成至少600道LeetCode题目</p><h1 id="范围"><a class="markdownIt-Anchor" href="#范围"></a> 范围</h1><ol><li>数组-Array-50</li><li>字符串-String-50</li><li>链表-Linked List-20</li><li>树-Tree-20</li><li>图-Graph-20</li><li>栈-Stack-20</li><li>堆-Heap-10</li><li>队列-Queue-9</li><li>哈希表-Hash Table-20</li><li>map-Ordered Map-10</li><li>并查集-Union Find-15</li><li>二叉搜索树-Binary Search Tree-4</li><li>后缀数组-Suffix Array-1</li><li>树状数组-Binary Indexed Tree-6</li><li>线段树-Segment Tree-10</li><li>字典树-Trie-10</li><li>位操作-Bit Manipulation-20</li><li>递归-Recursion-10</li><li>深度优先搜索-Depth-first Search-20</li><li>广度优先搜索-Breadth-first Search-20</li><li>二分搜索-Binary Search-20</li><li>双指针-Two Pointers-20</li><li>滑动窗口-Sliding Window-10</li><li>回溯-Backtracking-20</li><li>排序-Sort-20</li><li>贪心-Greedy-20</li><li>分治-Divide and Conquer-15</li><li>动态规划-Dynamic Programming-50</li><li>数学-Math-20</li><li>设计-Design-20</li><li>拓扑排序-Topological Sort-6</li><li>滚动哈希-Rolling Hash-2</li><li>行扫描-Line Sweep-6</li><li>极小化极大-Minimax-8</li><li>记忆化-Memoization-1</li><li>几何方法-Geometry-9</li><li>随机-Random-6</li><li>脑筋急转弯-Brainteaser-7</li><li>蓄水池抽样-Reservoir Sampling-2</li><li>拒绝采样-Rejection Sampling-2</li></ol><h1 id="原则"><a class="markdownIt-Anchor" href="#原则"></a> 原则</h1><ul><li><p>按tag刷题</p></li><li><p>每道题完全掌握、使用多种方法</p></li><li><p>无参考实现bug free</p></li><li><p>思路清晰，书写报告</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 工作相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    
    
    
    
    
  
  
</search>
